## Словари
<br>  

***Задание 1***  
Перед вами данные о картинах и их авторах.

| Название картины         | Автор            |
|--------------------------|------------------|
| Крик                     | Мунк Эдвард      |
| Неизвестная              | Крамской Иван    |
| Итальянский полдень      | Брюллов Карл     |
| Рожь                     | Шишкин Иван      |
| Звёздная ночь            | Ван Гог Винсент  |

Сохраните эти данные в виде словаря, где ключами словаря станут названия картин, а значениями — их авторы. Сохраните словарь в переменной ```arts_dict```.
```
arts_dict ={
    'Крик':'Мунк Эдвард',
    'Неизвестная':'Крамской Иван',
    'Итальянский полдень':'Брюллов Карл',
    'Рожь':'Шишкин Иван',
    'Звёздная ночь':'Ван Гог Винсент',
}

print(arts_dict)
-

{'Крик': 'Мунк Эдвард', 'Неизвестная': 'Крамской Иван', 'Итальянский полдень': 'Брюллов Карл', 'Рожь': 'Шишкин Иван', 'Звёздная ночь': 'Ван Гог Винсент'}
```
<br>  

***Задание 2***  
Добавьте в словарь ещё одну картину. Автор — Айвазовский Иван, название — «Девятый вал».
```
arts_dict = {
    'Звёздная ночь': 'Ван Гог Винсент',
    'Крик': 'Мунк Эдвард',
    'Неизвестная': 'Крамской Иван',
    'Итальянский полдень': 'Брюллов Карл',
    'Рожь': 'Шишкин Иван'
}

arts_dict['Девятый вал'] = 'Айвазовский Иван'

print(arts_dict)
-

{'Звёздная ночь': 'Ван Гог Винсент', 'Крик': 'Мунк Эдвард', 'Неизвестная': 'Крамской Иван', 'Итальянский полдень': 'Брюллов Карл', 'Рожь': 'Шишкин Иван', 'Девятый вал': 'Айвазовский Иван'}
```
<br>  

***Задание 3***  
Напишите функцию ```art_check```, которая проверяет, есть ли картина в словаре. Если картина есть, то функция выводит на экран сообщение: ```'Такая картина есть! Автор: {имя автора}'```, в ином случае функция выводит сообщение: ```'К сожалению, такой картины не нашлось.'```.  
Например, для картины Девятый вал функция вернёт сообщение: ```'Такая картина есть! Автор: Айвазовский Иван'.```
```
# создаем словарь
arts_dict = {               
        'Звёздная ночь': 'Ван Гог Винсент',
        'Крик': 'Мунк Эдвард',
        'Неизвестная': 'Крамской Иван',
        'Итальянский полдень': 'Брюллов Карл',
        'Рожь': 'Шишкин Иван',
        'Девятый вал': 'Айвазовский Иван'
    }

# цикл для перебора ключей .keys() в словаре
def art_check(art):
    for paint in arts_dict.keys():
        if arts_dict.get(art) != None: # если не вернет none значит картина есть
            print(f'Такая картина есть! Автор: {arts_dict[art]}')
        elif arts_dict.get(art) == None: # если вернет none значит картины нет
             print('К сожалению, такой картины не нашлось.')
        break               
    
art_check('Девятый вал')
art_check('Рожь')
art_check('Среди волн')
-

Такая картина есть! Автор: Айвазовский Иван
Такая картина есть! Автор: Шишкин Иван
К сожалению, такой картины не нашлось.
```
<br>  

***Задание 4***  
Немного изменим словарь ```arts_dict```. Теперь для каждой картины есть информация об авторе и о годе создания. Найдите самую старую картину в словаре. Выведите название картины и год создания.
```
arts_dict = {
    'Звёздная ночь': {
        'authour': 'Ван Гог Винсент',
        'year': 1889
    },
    'Крик': {
        'authour': 'Мунк Эдвард',
        'year': 1910
    },
    'Неизвестная': {
        'authour': 'Крамской Иван',
        'year': 1883
    },
    'Итальянский полдень': {
        'authour': 'Брюллов Карл',
        'year': 1827
    },
    'Рожь': {
        'authour': 'Шишкин Иван',
        'year': 1878
    },
    'Девятый вал': {
        'authour': 'Айвазовский Иван',
        'year': 1850
    }
}

year = 2024
oldest_art = str()

for painting, details in arts_dict.items():
    if details['year'] < year:
        year = details['year']
        oldest_art = painting

print(oldest_art, year)
-

Итальянский полдень 1827
```
## Заполнение датафрейма
<br>  

***Задание 1***  
Создайте датафрейм и сохраните его в переменной ```df```.  
```
import pandas as pd

df = pd.DataFrame()
```
<br>  

***Задание 2***  
Снова создайте датафрейм без содержимого, но теперь с двумя колонками: имя и год рождения.  
```
import pandas as pd

df = pd.DataFrame(columns = ['имя', 'год рождения'])
print(df)
-

Empty DataFrame
Columns: [имя, год рождения]
Index: []
```
<br>  

***Задание 3***  
Сохраните значения ```names```, ```years``` в колонках датафрейма. Выведите датафрейм.
```
import pandas as pd

names = ['Вася', 'Петя', 'Таня', 'Маша']
years = [1996, 2001, 1998, 1997]
dat = {
    'имя':names,
    'год рождения':years
}

df = pd.DataFrame(dat)

print(df)
-

|    имя |год рождения|
|--------|------------|
|0  Вася |        1996|
|1  Петя |        2001|
|2  Таня |        1998|
|3  Маша |        1997|
```
<br>  

***Задание 4***  
Представьте данные из таблицы в виде словаря. На основе словаря создайте датафрейм.  

|    имя |год рождения|
|--------|------------|
|0  Вася |        1996|
|1  Петя |        2001|
|2  Таня |        1998|
|3  Маша |        1997|

```
import pandas as pd

data = {
        'имя':['Вася', 'Петя', 'Таня', 'Маша'],
        'год рождения':[1996, 2001, 1998, 1997]
        }
df = pd.DataFrame(data)

print(df)
-

|    имя |год рождения|
|--------|------------|
|0  Вася |        1996|
|1  Петя |        2001|
|2  Таня |        1998|
|3  Маша |        1997|
```
<br>  

***Задание 5***  
Представьте те же самые данные в виде вложенного списка. На основе списка создайте датафрейм.  
```
import pandas as pd

data = [['Вася', '1996'], # Заполните data данными
        ['Петя', '2001'],
        ['Таня', '1998'],
        ['Маша', '1997']]
df = pd.DataFrame(data = data, columns = ['имя', 'год рождения'])

print(df)
-

|    имя |год рождения|
|--------|------------|
|0  Вася |        1996|
|1  Петя |        2001|
|2  Таня |        1998|
|3  Маша |        1997|
```
<br>  

***Задание 6***  
Заполните датафрейм данными из таблицы любым удобным способом. Выведите датафрейм.
```
import pandas as pd

col = {
    'product_id':['#0001', '#0024', '#0201', '#0142', '#0032'],
    'product_name':['Подушка', 'Сковородка', 'Телевизор', 'Наушники', 'Телефон'],
    'company_name':['Idea', 'Tofal', 'Samfung', 'Sonya', 'Pineapple'],
    'price':[790, 1890, 52900, 33400, 96990]
}

df = pd.DataFrame(data = col)

print(df)
-

| product_id | product_name        | company_name     | price |
|------------|---------------------|------------------|-------|
| #0001      | Подушка             | Idea             | 790   |
| #0024      | Сковородка          | Tofal            | 1890  |
| #0201      | Телевизор           | Samfung          | 52900 |
| #0142      | Наушники            | Sonya            | 33400 |
| #0032      | Телефон             | Pineapple        | 96990 |
```
## Выгрузка датафрейма из файла
<br>  

***Задание 1***  
Выгрузите данные из файла ```orders_shop_items.csv``` и сохраните результат в переменной ```df```. Выведите содержимое датафрейма. Файл лежит в директории ```datasets```. Путь к файлу:```/datasets/orders_shop_items.csv```.  
```
import pandas as pd

df = pd.read_csv('/datasets/orders_shop_items.csv')

print(df)
```
<br>  

***Задание 2***  
Выведите первые десять строчек датафрейма ```df```. Для вывода используйте функцию ```print()```.
```
import pandas as pd

df = pd.read_csv('/datasets/orders_shop_items.csv')

print(df.head(10))
```
<br>  

***Задание 3***  
Выведите последние десять строчек датафрейма ```df```. Для вывода используйте функцию ```print()```.
```
import pandas as pd

df = pd.read_csv('/datasets/orders_shop_items.csv')

print(df.tail(10))
```
<br>  

***Задание 4***  
Выведите случайную строку из датафрейма ```df```. Для вывода используйте функцию ```print()```.
```
import pandas as pd

df = pd.read_csv('/datasets/orders_shop_items.csv')

print(df.sample()) 
```
<br>  

***Задание 5***  
Выведите количество строк в датафрейме.  
```
import pandas as pd

df = pd.read_csv('/datasets/orders_shop_items.csv')

print(df.shape[0])
```
<br>  

***Задание 6***  
Выгрузите данные из файла ```imdb_reviews.tsv```. Выведите информацию о данных в датафрейме и занимаемом ими размере. Файл находится в той же директории ```datasets```.
```
import pandas as pd

df = pd.read_csv('/datasets/imdb_reviews.tsv', sep='\t')

print(df.info())
```
## Фильтрация по столбцам
<br>  

***Задание 1***  
Загрузите датасет в переменную ```orders``` и выведите первые пять строк на экран для ознакомления. Сопоставьте содержимое данных с их описанием.
```
# импортируем библиотеку
import pandas as pd

# читаем csv 
orders = pd.read_csv('/datasets/orders_shop_rel.csv')

# выводим первые 5 строк датафрейма
print(orders.head())
```
<br>  

***Задание 2***  
Датафрейм orders содержит столбец ```Unnamed: 0```, который дублирует значения индекса. Такое может происходить при экспорте данных из pandas в форматы ```.csv``` или ```.xslx``` (формат Excel). Этот столбец не пригодится в дальнейшем, поэтому давайте удалим его и сохраним изменения в текущем датафрейме. Для удаления используйте метод ```.drop()```.  
Проверьте результат — после удаления с помощью метода ```head()``` выведите первые три строки на экран.  
```
# импорт библиотеки pandas и загрузка данных датасета orders_shop_rel.csv:
import pandas as pd
orders = pd.read_csv('/datasets/orders_shop_rel.csv')

# удаляем поле 'Unnamed: 0' в исходном датафрейме
orders.drop(columns=['Unnamed: 0'], inplace=True)

print(orders.head(3))
```
<br>  

***Задание 3***  
В прошлом задании вы отлично справились с удалением столбца при помощи метода ```.drop()```. Однако могут быть случаи, когда столбцы, подобные ```Unnamed: 0```,  содержат индекс датасета, который необходимо установить при загрузке. Загрузите датасет с указанием ```Unnamed: 0``` в качестве индекса датафрейма.  
Выведите первые три строки на экран с помощью метода ```head()```.  
```
# импорт библиотеки pandas:
import pandas as pd

# загрузка данных датасета orders_shop_rel.csv с объявлением индекса
orders = pd.read_csv('/datasets/orders_shop_rel.csv', index_col = 'Unnamed: 0')

print(orders.head(3))
```
<br>  

***Задание 4***  
Для актуализации списка клиентов магазина маркетологи просят прислать имя, фамилию и электронную почту каждого клиента. Используя оператор [], создайте срез данных, который будет содержать только столбцы с необходимой информацией. Сохраните результат фильтрации в переменную ```clients``` и выведите первые пять строк для того, чтобы проверить результат фильтрации данных. 
```
# импорт библиотеки pandas и загрузка данных датасета orders_shop_rel.csv:
import pandas as pd
orders = pd.read_csv('/datasets/orders_shop_rel.csv', index_col='Unnamed: 0')

# формируем срез данных из заданных полей
clients = orders[['first_name', 'last_name', 'email']]

print(clients.head())
```
<br>  

***Задание 5***  
Для фильтрации данных можно не только выбирать нужные, но и удалять ненужные столбцы. В одном из предыдущих заданий вы отлично справились с удалением столбца ```'Unnamed: 0'```. В этом задании удалите из датафрейма столбцы ```'total_amt'``` и ```'items_cnt'```, используя метод ```.drop()```. Результат сохраните в исходном датафрейме. В завершение выведите первые пять строк обновлённого датафрейма. 
```
# импорт библиотеки pandas и загрузка данных датасета orders_shop_rel.csv:
import pandas as pd
orders = pd.read_csv('/datasets/orders_shop_rel.csv', index_col='Unnamed: 0')

# удалим избыточные столбцы:
orders.drop(columns = ['total_amt', 'items_cnt'], inplace = True)

print(orders.head())
```
## Фильтрация по строкам при помощи индексации
<br>  

***Задание 1***  
Нужно составить рейтинг клиентов по количеству совершённых заказов. Для этого проведите фильтрацию данных по общему количеству заказанных товаров — отсортируйте  столбец ```'items_cnt'``` в порядке убывания значений. Сохраните результат в переменной result и затем оставьте в новом датафрейме только первые 7 строк, используя оператор ```[]```.
```
# Импорт библиотеки pandas и загрузка данных датасета orders_shop_rel.csv:
import pandas as pd
orders = pd.read_csv('/datasets/orders_shop_rel.csv').drop(columns='Unnamed: 0')

# сортировка по столбцу 'items_cnt' в порядке убывания, срез первые 7 строк 
result = orders.sort_values(by = 'items_cnt', ascending = False)[:7]

print(result)
```
<br>  

***Задание 2***  
Маркетинговый отдел решил провести акцию и предложить 50 клиентам, которые совершили большое количество заказов купоны на скидки. При этом для первых десяти клиентов бонусные условия отличаются от остальных. Ваша задача подготовить две выборки данных:  
* top_10 — выборка, которая включает первых десять клиентов по общему количеству заказов;  
* top_40 — выборка, которая включает срез клиентов, занявших 11-50 места по количеству заказов.  

Чтобы сформировать два списка, отсортируйте данные по количеству заказанных товаров — столбец ```'items_cnt'``` в порядке убывания значений. Сохраните результат в отдельной переменной, название переменной задайте сами.   
Затем, используя отсортированные данные и оператор ```[]```, сделайте два среза ```top_10``` и ```top_40```, в которых будут только персональные данные клиентов — столбцы ```'first_name'```, ```'last_name'``` и ```'email'```.  
Для проверки результата выведите на экран с помощью функции ```print()``` последние две строки датафрейма ```top_10``` и первые две строки датафрейма ```top_40```. Так вы убедитесь, что фильтрация прошла корректно и нет пересечения значений между двумя срезами данных.
```
# Импорт библиотеки pandas и загрузка данных датасета orders_shop_rel.csv:
import pandas as pd
orders = pd.read_csv('/datasets/orders_shop_rel.csv').drop(columns='Unnamed: 0')

# формируем топ-10 и топ-40, сортируем по полю 'items_cnt' в порядке убывания и оставляем необходимые по заданию поля
top_10 = orders.sort_values(by = 'items_cnt', ascending = False)[:10][['first_name', 'last_name', 'email']]
top_40 = orders.sort_values(by = 'items_cnt', ascending = False)[10:50][['first_name', 'last_name', 'email']]

# Выведем на экран результат - первые две строки каждого среза данных:
print(top_10.tail(2))
print(top_40.head(2))
```
<br>  

***Задание 3***  
Менеджеры отдела продаж попросили детализировать покупки, совершенные клиентом с почтой ```'Sunita_Tanaka1992@mail.com'```, а это отличная задача для логической индексации! С помощью неё и оператора ```[]``` создайте необходимый срез данных и выведите его на экран, используя ```print()```. Результат отсортируйте по увеличению номера заказа — ```'order_id'```.
```
# Импорт библиотеки pandas и загрузка данных датасета orders_shop_rel.csv:
import pandas as pd
orders = pd.read_csv('/datasets/orders_shop_rel.csv').drop(columns='Unnamed: 0')

# фильтрация поля 'email' по маске 
mask = orders[orders['email'] == 'Sunita_Tanaka1992@mail.com']

# сортировка по 'order_id' в порядке возрастания
result = mask.sort_values(by = 'order_id')

# вывод результата на экран
print(result)
```
<br>  

***Задание 4***  
Для анализа данных поступила ещё одна задача — проанализировать продажи товаров категорий ```gadget``` и ```device``` с высокой стоимостью. К таким товарам относятся:  
* категория ```gadget``` и стоимость выше 100;  
* категория ```device``` и стоимость выше 200;  

Используйте логическую маску и оператор ```[]```, чтобы провести логическую индексацию датафрейма ```orders``` и выбрать все покупки, которые включали товары ```gadget``` и ```device``` с высокой стоимостью. Стоимость товара возьмите из столбца price.  
Результат сохраните в датафрейме ```results``` и выведите первые пять строк этого датафрейма на экран.
```
# Импорт библиотеки pandas и загрузка данных датасета orders_shop_rel.csv:
import pandas as pd
orders = pd.read_csv('/datasets/orders_shop_rel.csv').drop(columns='Unnamed: 0')

# формирование масок для фильтрации фрейма по условию
mask_for_gadget = (orders['category'] == 'gadget') & (orders['price'] > 100)
mask_for_device = (orders['category'] == 'device') & (orders['price'] > 200)

# определение нового дф через фильтрацию 
results = orders[mask_for_gadget | mask_for_device]

# вывод на экран результирующего набора из 5 строк
print(results[:5])
```
## Фильтрация при помощи loc и iloc
<br>  

***Задание 1***  
Сохраните данные ```orders_shop_items.csv``` в датафрейм ```items```. Проведите сортировку датафрейма ```items``` по общему количеству покупок ```(orders)``` в порядке убывания — то есть от большего к меньшему и создайте с помощью оператора ```.loc[]``` выборку, содержащую первые десять строк столбцов ```'category'```, ```'item_name'``` и ```'orders'```. Это будет список «Топ-10 самых популярных товаров».  
Результат сохраните в переменной ```top_10_items``` и выведите его на экран.  
```
# Импортируем библиотеку pandas и загрузим данные датасета orders_shop_items.csv:
import pandas as pd
items = pd.read_csv('/datasets/orders_shop_items.csv')

# Проведем сортировку датафрейма items по снижению значений 'orders':
sorted_df = items.sort_values(by = 'orders', ascending = False)

# Сбросим индекс датафрейма sorted_df:
sorted_df = sorted_df.reset_index(drop=True)

# Создадим срез данных, включающий первые 10 строк столбцов:
# 'category','item_name' и 'orders':
top_10_items = sorted_df.loc[:9, ['category', 'item_name', 'orders']]

# Выведем результат на экран:
print(top_10_items)
```
<br>  

***Задание 2***  
В прошлом задании для создания выборки, содержащей первые десять строк, вы использовали оператор ```.loc[]```. Однако в этом случае пришлось сбрасывать индекс с помощью метода ```reset_index()```, поскольку после сортировки данных мы не можем точно знать метки индексов нужных строк. Оператор ```.iloc[]``` для индексации использует целочисленные значения индексов, то есть порядковые номера строк и столбцов, поэтому его удобно использовать для выборки строк определённого интервала, после изменения индекса.  
Потренируйтесь это делать. Как раз появилась задача от отдела продаж интернет-магазина полезных устройств — создать список из 50 самых дорогих товаров категорий apparatus и ```module```, который будет включать столбцы ```category``` и ```item_name```.  Для этого в начале создайте выборку товаров нужных категорий и отсортируйте их по стоимости, а затем, с помощью оператора ```.iloc[]``` выберите необходимое количество строк и сохраните результат в переменной ```results```.  
В завершении выведите первые пять строк созданного датафрейма ```results``` с помощью метода ```.head()```.  
```
# Импортируем библиотеку pandas и загрузим данные датасета orders_shop_items.csv:
import pandas as pd
items = pd.read_csv('/datasets/orders_shop_items.csv')

# формируем логическую маску для отбора категорий 
results = (items['category'] == 'apparatus') | (items['category'] == 'module')

# фильтруем датафрейм по созданной маске
results = items[results]

# сортируем по убыванию цены
results = results.sort_values(by = 'price', ascending = False)

# выбираем первые 50 записей, возвращаем две колонки category и item_name
results = results.iloc[0:50, 0:2]

# выводим на экран первые 5 строк
print(results.head())

```
<br>  

***Задание 3***  
Продолжим исследовать данные по продажам. Выберите товары, у которых количество покупок orders больше, чем количество уникальных покупателей ```buyers```. Это значит, что товар пользуется интересом у клиентов и некоторые купили его несколько раз. Результат сохраните в переменной ```popular_items``` в виде серии значений ```(pandas.Series)``` столбца с названием товара ```item_name```.  
В завершении выведите на экран с помощью функции ```print()``` количество товаров в ```popular_items```. 
```
# Импортируем библиотеку pandas и загрузим данные датасета orders_shop_items.csv:
import pandas as pd
items = pd.read_csv('/datasets/orders_shop_items.csv')

# маска для сравнения условия oreders < buyers
buyers = (items['buyers']) < (items['orders'])

# фильтруем датафрейм по маске
popular_items = items[buyers]

# создаем список популярных товаров в формате series
popular_items = popular_items['item_name']

# выводим на экран количество товаров отвечающих условию задачи
print(len(popular_items))
```
## Фильтрация при помощи query
<br>  

***Задание 1***  
Необходимо проанализировать данные датасета ```orders_shop_buyers.csv``` и выявить клиентов, не совершивших ни одного заказа. После этого нужно подсчитать их долю. Для этого используя запрос query, сделайте срез данных, содержащий информацию о клиентах, у которых значение ```orders = 0```. Результат сохраните в переменной ```wo_purchases```. Затем подсчитайте долю клиентов, которые не совершили ни одного заказа — поделите количество строк датафрейма ```wo_purchases``` на количество строк исходного датафрейма ```buyers```. Результат выведите на экран.
```
# Импортируйте библиотеку pandas и загрузите данные датасета orders_shop_buyers.csv:
import pandas as pd
buyers = pd.read_csv('/datasets/orders_shop_buyers.csv')

# получаем количество клиентов, которые ничего не покупали
wo_purchases = buyers.query('orders == 0')

# находим долю таких клиентов от общего числа
x = wo_purchases.shape[0] / buyers.shape[0]

# выводим результат на экран
print(x)
```
<br>  

***Задание 2***  
Найдите тех, кто оформил три и более заказов ```(orders)```, или купил пять и более товаров ```(items)```. Для этого используя запрос query, сделайте срез данных активных клиентов, содержащий имя и фамилию клиента — ```first_name``` и ```last_name```, а также имейл — ```email```. Результат сохраните в переменной ```active_clients``` и выведите на экран первые пять строк нового датафрейма.  
```
# Импортируейте библиотеку pandas и загрузите данные датасета orders_shop_buyers.csv:
import pandas as pd
buyers = pd.read_csv('/datasets/orders_shop_buyers.csv')

# задаем условия для фильтрация по строкам и столбцам
active_clients = buyers.query('orders >= 3 or items >= 5')[['first_name', 'last_name', 'email']]

# выводим первые пять строк результирующего набора
print(active_clients.head())
```
<br>

***Задание 3***  
Вам предстоит проанализировать среднюю стоимость товаров, купленных клиентами, и выделить клиентов, предпочитающих покупать дорогие устройства. Для этого необходимо подсчитать среднюю стоимость купленных товаров, который приобрел каждый клиент. Затем найти клиентов, купивших более одного устройства ```(items)``` средней стоимостью выше 300 условных единиц. Для решения этой задачи используйте запрос ```query```.   
Результат сохраните в переменной ```active_clients```, отсортируйте по убыванию значений ```total_price``` и выведите на экран первые пять строк нового датафрейма. Среднюю стоимость товара можно найти как отношение ```total_price / items``` — используйте его в самом запросе ```query```.  
```
# Импортируйте библиотеку pandas и загрузим данные датасета orders_shop_buyers.csv:
import pandas as pd
buyers = pd.read_csv('/datasets/orders_shop_buyers.csv')

# фильтруем датафрейм в соотвествии с условиями задачи
active_clients = buyers.query('total_price / items > 300 and items > 1')

# сортируем по убыванию общей стоимости
active_clients = active_clients.sort_values(by = 'total_price', ascending = False)

# возвращаем первые 5 строк результирующего набора
print(active_clients.head()) 
```
<br>

***Задание 4***  
В этом задании вы проанализируете клиентов исходя из стоимости всех заказов ```total_price:``` найдёте покупателей, потративших на все заказы больше, чем в среднем. Для этого сравните стоимость всех заказов конкретного клиента и средний показатель этого значения среди всех клиентов. Для решения используйте запросы ```query```, а результат сохраните в датафрейме ```active_clients``` и выведите на экран первые пять строк нового датафрейма. 
```
# Импортируем библиотеку pandas и загрузим данные датасета orders_shop_buyers.csv:
import pandas as pd
buyers = pd.read_csv('/datasets/orders_shop_buyers.csv')

# отсеиваем клиентов, которые ничего не купили
buyers_more_then_one = buyers.query('orders > 0')

# фильтруем общую стоиомсть так, чтобы она превышала среднее значение, используя метод .meaт()
active_clients = buyers_more_then_one.query('total_price > total_price.mean()')

# выводим результат
print(active_clients.head())
```
## Действия над названиями столбцов
<br>  

***Задание 1***  
В прошлых уроках вы уже познакомились с данными Яндекс Музыки. Названия столбцов в них приведены к нотации ```Snake Case```. Однако после обновления данных в названии столбцов возникли проблемы.
Импортируйте библиотеку pandas и загрузите датасет Яндекс Музыки ```music_log.csv``` в переменную ```music_df```. Затем выведите на экран названия столбцов, а следующей строкой укажите сколько столбцов (целое значение) датафрейма ```music_df``` нуждаются в корректировке названия.
```
# Импорт библиотеки pandas и загрузка данных датасета music_log.csv:
import pandas as pd # напишите ваш код здесь
music_df = pd.read_csv('/datasets/music_log.csv')

# Выведем на экран названия всех столбцов с помощью атрибута DataFrame columns:
print(music_df.columns)

# Выведем на экран количество столбов, которые необходимо скорректировать:
print(3)# введите вручную число )
```
<br>  

***Задание 2***  
Переведите вручную названия всех столбцов датафрейма ```music_df``` к виду ```snake_case```, используя атрибут датафрейма ```columns```. Перед изменением названий, новые названия датафрейма сохраните в списке new_columns. Результат выведите на экран.   
```
# Импорт библиотеки pandas и загрузка данных датасета music_log.csv:
import pandas as pd
music_df = pd.read_csv('/datasets/music_log.csv')

# Выведем на экран названия всех столбцов с помощью атрибута DataFrame columns:
print(music_df.columns)

# Новые названия всех столбцов исходного датафрейма в нотации **snake_case**:
new_columns = ['user_id', 'total_play', 'artist', 'genre', 'track']

# Заменим исходные названия столбцов на новые, используя атрибут columns:
music_df.columns = new_columns

# Выведем на экран обновленные названия столбцов, используя атрибут columns:
print(music_df.columns)
```
<br>  

***Задание 3***  
Поскольку в исходном датафрейме ```music_df``` нужно изменить названия только части столбцов, то проведите замену их названий с помощью метода ```.rename()```. Чтобы передать новые названия методу ```.rename()```, создайте словарь ```new_columns```. Результат изменения названия столбцов выведите на экран.  
```
# Импорт библиотеки pandas и загрузка данных датасета music_log.csv:
import pandas as pd
music_df = pd.read_csv('/datasets/music_log.csv')

# Для замены названий столбцов создадим словарь new_columns, содержащий старое и новое названия:
new_columns = {
    '  user_id' : 'user_id',
    'total play' : 'total_play',
    'Artist' : 'artist'
}

# Заменим исходные названия столбцов на новые, используя метод .rename():
music_df.rename(columns = new_columns, inplace = True)

# Выведем на экран обновленные названия столбцов:
print(music_df.columns)
```
<br>  

***Задание 4***  
Если проанализировать названия исходных столбцов, то основные ошибки связаны с лишними пробелами в начале названий, использованием пробелов между словами и различающимся регистром символов. Смысловых опечаток в названии столбцов нет. Поэтому, чтобы перевести названия столбцов в snake_case, достаточно использовать строковые методы, которые проводят преобразования строки:  
* ```.replace()``` — для замены пробела на символ _;  
* ```.lower()``` — для изменения регистра символов на нижний;  
* ```.strip()``` — для удаления всех пробелов в начале и конце строки.  

Используя строковые методы и аксессор str, приведите названия столбцов к единому виду в нотации snake_case. Результат изменения выведите на экран.  
```
# Импорт библиотеки pandas и загрузка данных датасета music_log.csv:
import pandas as pd
music_df = pd.read_csv('https://code.s3.yandex.net/datasets/music_log.csv')

# Для замены названий столбцов используйте цепочку строковых методов:
music_df.columns = music_df.columns.str.strip().str.lower().str.replace(' ', '_')

# Выведем на экран обновленные названия столбцов:
print(music_df.columns)
```
## Методы замены данных по условию
<br>  

***Задание 1***  
Если вы посмотрите на все уникальные значение поп-стилей из данных Яндекс Музыки ```['asiapop', 'cantopop', 'dancepop', 'electropop', 'indipop', 'jpop', 'k-pop', 'mandopop', 'pop', 'ruspop', 'synthpop']```, то заметите, что ```K-pop```, ```Dance-pop```, ```Indie pop```, ```J-pop``` и ```Synth-pop``` записаны слитно, кроме одного — ```'k-pop'```. Все направления популярной музыки должны быть записаны в едином стиле. Для этого замените все значения ```'k-pop'``` в столбце ```genre``` на ```'kpop'```. Изменения сохраните в датафрейме без переприсвоения. После этого подсчитайте количество строк, содержащих жанр ```'kpop'```, результат выведите на экран.
```
# Импортируем библиотеку pandas и загрузим данные датасета music_log.csv:
import pandas as pd
music_df = pd.read_csv('/datasets/music_log.csv')

# Проведём предварительную подготовку названия столбцов - трансформируем в нотацию snake_case:
music_df.columns = music_df.columns.str.strip().str.replace(' ', '_').str.lower()

# Заменим значение 'k-pop' на 'kpop' в столбце 'genre':
music_df['genre'].replace('k-pop', 'kpop', inplace=True)

# Сохраним срез данных с песнями жанра kpop в отдельный датафрейм:
kpop = music_df[music_df['genre'] == 'kpop']

# Подсчитаем количество строк и выведем их количество на экран:
print(len(kpop))
```
<br>  

***Задание 2***  
В названии столбцов обнаружились дополнительные неточности: один и тот же жанр указан по-разному. Например, ```hard'n'heavy``` и ```hard-n-heavy```, или ```türk``` и ```türkçe```. Замените названия этих жанров на ```hard_n_heavy``` и ```turkish```. Результат сохраните в исходном датафрейме.  
В завершении подсчитаете количество строк, которые занимают композиции в этих жанров.  
```
# Импортируем библиотеку pandas и загрузим данные датасета music_log.csv:
import pandas as pd
music_df = pd.read_csv('/datasets/music_log.csv')

# Проведём предварительную подготовку названия столбцов - трансформируем в нотацию snake_case:
music_df.columns = music_df.columns.str.strip().str.replace(' ', '_').str.lower()

# Создадим словарь с изменяемыми значениями:
new_genres = {
    "hard'n'heavy" : "hard_n_heavy",
    "hard-n-heavy" : "hard_n_heavy",
    "türk" : "turkish",
    "türkçe" : "turkish"
}

# Проведём замену данных:
music_df.replace(new_genres, inplace = True)

# Подсчитаем количество строк и выведем их количество на экран:
cnt = music_df[(music_df['genre'] == 'turkish') | (music_df['genre'] == 'hard_n_heavy')]
print(len(cnt)) 
```
<br>  

***Задание 3***  
Теперь вам предстоит определить популярные песни. На основе данных о длительности прослушивания песни определённым пользователем ```total_play``` создайте столбец ```is_popular``` с флагом, является ли песня популярной или нет. В качестве популярных учитывайте песни, длительность проигрывания ```total_play``` которых свыше 1000 минут.  
После этого подсчитайте количество строк, содержащих популярные композиции, результат выведите на экран.  
```
# Импортируем библиотеку pandas и загрузим данные датасета music_log.csv:
import pandas as pd
music_df = pd.read_csv('/datasets/music_log.csv')

# Проведём предварительную подготовку названия столбцов - трансформируем в нотацию snake_case:
music_df.columns = music_df.columns.str.strip().str.replace(' ', '_').str.lower()

# Создадим новый столбец is_popular и зададим его значение через логическую маску:
music_df['is_popular'] = False
mask = music_df.query('total_play > 1000').index
music_df.loc[mask, 'is_popular'] = True

# Сохраним срез данных с популярными песнями в отдельный датафрейм:
popular = music_df[(music_df['is_popular'] == True)]

# Подсчитаем количество строк и выведем их количество на экран:
print(len(popular))
```
<br>  

***Задание 4***  
В прошлом задании вы определили популярные песни, которые прослушивали более 1000 минут. Однако список популярных песен необходимо обновить согласно новому условию: если стиль песен ```'folk'```, ```'folklore'```, ```'folkmetal'``` и ```'folkrock'```, то их можно считать популярными, если длительность прослушивания превысила 300 минут.  
Проведите необходимые изменения в столбце```is_popular``` и подсчитайте обновлённое количество строк с меткой ```is_popular = True```. Для выбора необходимых строк используйте запрос ```.query()```.
```
# Импортируем библиотеку pandas и загрузим данные датасета music_log.csv:
import pandas as pd
music_df = pd.read_csv('/datasets/music_log.csv')

# Проведём предварительную подготовку названия столбцов - трансформируем в нотацию snake_case:
music_df.columns = music_df.columns.str.strip().str.replace(' ', '_').str.lower()

# Создадим новый столбец is_popular и зададим его значение через логическую маску:
music_df['is_popular'] = music_df['total_play'] > 1000

# Перечисляем жанры песен, для которых необходимо проверить условие
music_genres = ['folk', 'folklore', 'folkmetal', 'folkrock']

# Напишем запрос query, который будем использовать для замены данных:
index_mask = music_df.query('genre in @music_genres and total_play > 300')

# Изменим с помощью логической индексации loc[] значение is_popular на True, если песня популярная по условию index_mask:
music_df.loc[index_mask.index, 'is_popular'] = True

# Сохраним срез данных с популярными песнями в отдельный датафрейм:
popular = music_df.query('is_popular == True')

# Подсчитаем количество строк и выведем их количество на экран:
print(popular.shape[0])  # Выводим количество строк с меткой is_popular = True
```
<br>  

***Задание 4***  
В 

 
